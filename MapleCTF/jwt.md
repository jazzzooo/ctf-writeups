# jwt

## The Challenge
We are given the source code of a Flask application. It allows registration and login. Once you log in, the following code runs:
```python
@app.route("/home", methods=["GET"])
def home():
    if hasattr(g, "user"):
        if g.user == "admin":
            message = f"Welcome back! Here's your flag {flag}"
        else:
            message = f"Welcome back {g.user}!"
        return render_template("home.html", message=message)

    flash("An error occurred - please login again")
    return redirect(url_for("login"))
```
`g` is the current session, which is stored in a signed JSON Web Token (jwt).
We see that the goal is to sign in as the user `admin`.

The challenge description reads:
> I just learned about JWT tokens,<br/>
> but everyone's using HS256 and RS256.<br/>
> Why not show some love for elliptic curves?<br/>

Sadly not a haiku, but we see that the website indeed uses a custom implementation of jwt, which relies on elliptic curves.

## The Solution
The `jwt.py` file contains a custom implementation of [ECDSA](https://wikiless.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm).
The ECDSA relies on a private key `d_a`, and a cryptographically secure random number `k`.
`k` must never be reused, else it will leak the private key.

The signature is generated by the following function:
```python
    def _sign(self, msg):
        z = sha256(msg.encode()).digest()
        k = self.private

        z = bl(z)

        r = (k * self.G).x
        s = inverse(k, self.order) * (z + r * self.private) % self.order

        return r, s
```
The problem becomes apparent: `k` is not random at all.
`k` is always set to the private key, and can be calculated easily; we obtain two signatures from two different tokens, and use them to calculate it.
The jwt token is saved in a cookie.

To find the cookies on Chromium, you press Ctrl + Shift + I, select the "Application" tab, expand the "Cookies" dropdown, and select the url of the page.
The token is in the cookie named "token".

```python
t1 = "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYXNkIn0.75J83TiCMONIDtDLvDQ8FKHa4wx7DNHkauX-Izu11S-w0EBxpBBpbnBng0E8regXVP6bWXZqJdztbmt1IxATAg"
t2 = "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiZHNhIn0.75J83TiCMONIDtDLvDQ8FKHa4wx7DNHkauX-Izu11S-iHYwnAEUV20Hrss4WoNecypMx7GuoIDzCOpprq-1o1w"
```

A jwt token is comprised of three parts: The header, payload and signature.
Each is encoded in url-safe base64.
To decode them, we can't rely on pyjwt because this implementation is non-standard.
Instead we use the code from the challenge.

```python
from base64 import urlsafe_b64decode, urlsafe_b64encode

def b64decode(msg: str) -> bytes:
    if len(msg) % 4 != 0:
        msg += "=" * (4 - len(msg) % 4)
    return urlsafe_b64decode(msg.encode())


t1 = t1.split(".")
t2 = t2.split(".")

print(b64decode(t1[0]))  # b'{"alg":"ES256","typ":"JWT"}'
print(b64decode(t1[1]))  # b'{"user":"asd"}'
```

Once again we follow the source code to read `r` and `s` from the encoded signature.

```python
sig1 = b64decode(t1[2])
sig2 = b64decode(t2[2])
r1 = int.from_bytes(sig1[:32], "little")
r2 = int.from_bytes(sig2[:32], "little")
s1 = int.from_bytes(sig1[32:], "little")
s2 = int.from_bytes(sig2[32:], "little")
```

We hash the messages.

```python
from hashlib import sha256

from Crypto.Util.number import bytes_to_long

msg1 = t1[0] + "." + t1[1]
msg2 = t2[0] + "." + t2[1]
h1 = sha256(msg1.encode()).digest()
h2 = sha256(msg2.encode()).digest()
h1 = bytes_to_long(h1)
h2 = bytes_to_long(h2)
```

We now have everything we need to recover the `k`. We get the order of the curve. All operations are done modulo the order.

```python
from fastecdsa.curve import secp256k1

order = secp256k1.q
k = (h2 - h1) * pow(s2 - s1, -1, order) % order
print(k)
# 48851004221674385686123624098528909906235635313442021459577134258726978602540
private = k
```

Finally, we can just steal some more code from the challenge to sign our message.

```python
from json import dumps


def b64encode(msg: bytes) -> str:
    return urlsafe_b64encode(msg).decode().rstrip("=")


def _sign(msg):
    z = sha256(msg.encode()).digest()
    # k = private
    z = bytes_to_long(z)

    r = (k * secp256k1.G).x
    s = pow(k, -1, order) * (z + r * private) % order
    return r, s


def sign(data):
    header = b64encode(dumps({"alg": "ES256", "typ": "JWT"}).replace(" ", "").encode())
    data = b64encode(dumps(data).replace(" ", "").encode())

    r, s = _sign(header + "." + data)
    signature = r.to_bytes(32, "little") + s.to_bytes(32, "little")

    return header + "." + data + "." + b64encode(signature)


print(sign({"user": "admin"}))
# eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.75J83TiCMONIDtDLvDQ8FKHa4wx7DNHkauX-Izu11S8IDLHy2P7MGS7FfPJpZagBzl8OHNHGZalfdll8sV55Kg
```

With this token in hand, we go back to the website, and paste it into the value field of the token cookie.
Once we refresh the page, we are logged in as admin and the flag is ours.
Scroll down further if you want an explanation of the math for recovering `k`.

## Full Code
```python
from base64 import urlsafe_b64decode, urlsafe_b64encode
from hashlib import sha256
from json import dumps

from Crypto.Util.number import bytes_to_long
from fastecdsa.curve import secp256k1


def b64decode(msg: str) -> bytes:
    if len(msg) % 4 != 0:
        msg += "=" * (4 - len(msg) % 4)
    return urlsafe_b64decode(msg.encode())


def b64encode(msg: bytes) -> str:
    return urlsafe_b64encode(msg).decode().rstrip("=")


def _sign(msg):
    z = sha256(msg.encode()).digest()
    # k = private
    z = bytes_to_long(z)

    r = (k * secp256k1.G).x
    s = pow(k, -1, order) * (z + r * private) % order
    return r, s


def sign(data):
    header = b64encode(dumps({"alg": "ES256", "typ": "JWT"}).replace(" ", "").encode())
    data = b64encode(dumps(data).replace(" ", "").encode())

    r, s = _sign(header + "." + data)
    signature = r.to_bytes(32, "little") + s.to_bytes(32, "little")

    return header + "." + data + "." + b64encode(signature)


t1 = "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYXNkIn0.75J83TiCMONIDtDLvDQ8FKHa4wx7DNHkauX-Izu11S-w0EBxpBBpbnBng0E8regXVP6bWXZqJdztbmt1IxATAg"
t2 = "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiZHNhIn0.75J83TiCMONIDtDLvDQ8FKHa4wx7DNHkauX-Izu11S-iHYwnAEUV20Hrss4WoNecypMx7GuoIDzCOpprq-1o1w"
t1 = t1.split(".")
t2 = t2.split(".")

sig1 = b64decode(t1[2])
sig2 = b64decode(t2[2])
s1 = int.from_bytes(sig1[32:], "little")
s2 = int.from_bytes(sig2[32:], "little")

msg1 = t1[0] + "." + t1[1]
msg2 = t2[0] + "." + t2[1]
h1 = sha256(msg1.encode()).digest()
h2 = sha256(msg2.encode()).digest()
h1 = bytes_to_long(h1)
h2 = bytes_to_long(h2)


order = secp256k1.q
k = (h2 - h1) * pow(s2 - s1, -1, order) % order
private = k


print(sign({"user": "admin"}))
# eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.75J83TiCMONIDtDLvDQ8FKHa4wx7DNHkauX-Izu11S8IDLHy2P7MGS7FfPJpZagBzl8OHNHGZalfdll8sV55Kg
```

## Recovering the Nonce
The ECSDA signature is comprised of two parts, `r` and `s`.

$$ r = kG $$

$$ s = \frac{h + rp}{k}$$

`G` is the generator of the curve. When we deal with points on the curve we only care about the x coordinate. <br>
`p` is the private key. <br>
`h` is the hash of the message. <br>
All operations are done modulo the order of the curve.
Lets see what happends when we subtract the `s` of two signatures which share the same nonce `k`.

$$ s_1 - s_2 = \frac{(h_1 + rp) - (h_2 + rp)}{k} = \frac{h_1 - h_2}{k} $$

$$ k = \frac{h_1 - h_2}{s_1 - s_2} $$

Exercise for the reader, how do you recover the private key after you find the nonce this way?
